# Bibim(비빔)
비빔은 당신의 두뇌를 즐겁게 만들어 줄 새로운 프로그래밍 언어입니다.

## 자료형
비빔의 자료형은 크게 Number와 Bowl, 두 가지로 구성됩니다.

### Number
Number는 비빔에서 '수'를 나타내는 자료형입니다.
비빔에서 '수'란 '유리수'를 의미합니다. 이러한 수는 부동소수점으로 표기되지 않고, 분수꼴로 표현됩니다. 따라서 비빔에서는 유리수 연산에서 오차가 발생하지 않습니다.

비빔에서 Number를 표현하기 위해서는 Number 구분자 `/`를 사용합니다. `/` 문자 앞에 사용된 Number를 분자로, `/` 문자 뒤에 사용된 Number를 분모로 사용하여 새로운 Number 값을 만듭니다.

예를 들어, 비빔에서 `3/5`는 유리수 3/5와 동일합니다. 또, `1/3`은 유리수 1/3과 동일합니다.

또, 정수 값들은 분모가 1인 Number입니다. 이 경우 `/` 문자를 생략하고 정수만을 표기하여 사용할 수 있습니다. (위의 예제에서도 분자와 분모로 사용된 숫자 1, 3, 5는 각각 분모가 생략된 Number입니다.)

### Noodle
Bowl에 대해 설명하기 앞서, Noodle에 대해 먼저 설명합니다.

Noodle은 비빔에서 어떠한 표현식(Expression)에 Noodle number를 부여하는 특수한 구문입니다(자료형이 아닙니다). Noodle은 `[` 문자로 시작하여 `]` 문자로 끝나며, 중간에 구분자 `;`를 가집니다. 구분자 `;`를 기준으로 앞의 표현식을 Noodle number, 뒤의 표현식을 Noodle exprsssion이라고 부릅니다.

예를 들면, `[3/4; 2/3]`와 같은 구문은 Noodle을 나타내며, Noodle number는 `3/4`, Noodle expression은 `2/3`입니다.

Noodle을 정의할 때, 구분자 `;`는 반드시 포함해야 하며, Noodle number와 Noodle expression 역시 반드시 포함해야 합니다.

### Bowl
Bowl은 Noodle의 뭉치로 표현되는 비빔에서 사용되는 특수한 자료형입니다.
이는 `{` 문자로 시작하여 `}` 문자로 끝나며, Noodle을 특별한 구분자 없이 담아 정의합니다.

예를 들면, 아래의 코드는 총 12개의 Noodle을 담고 있는 Bowl입니다.

    {
        [0; 72]
        [1; 69]
        [2; 76]
        [3; 76]
        [4; 79]
        [5; 32]
        [6; 87]
        [7; 79]
        [8; 82]
        [9; 76]
        [10; 68]
        [11; 10]
    }

또한 어떠한 Noodle도 담고 있지 않는 Bowl 역시 정의할 수 있는데, 이 경우는 간단히 `{}`와 같이 표현합니다.

## 연산자
이제 비빔에서 사용할 수 있는 연산자에 대해 알아봅시다.

### 소괄호
소괄호 문자 `(`, `)`를 사용하여 표현식의 연산 우선순위를 지정할 수 있습니다.
비빔은 소괄호 안의 표현식을 우선적으로 평가합니다.

### 덧셈, 뺄셈, 곱셈
비빔에서는 각각 `+`, `-`, `*` 연산자를 이용하여 두 Number간의 덧셈, 뺄셈과 곱셈 연산을 수행할 수 있습니다.
예를 들어 `1/4 + 1/2`의 연산 결과는 `3/4`가 됩니다.

곱셈은 덧셈과 뺄셈보다 높은 우선순위로 평가되며, 덧셈가 뺄셈은 동일한 우선순위를 같습니다.
동일한 우선순위를 가지는 덧셈, 뺄셈, 곱셈 연산자는 왼쪽부터 평가됩니다.

예를 들어, `2 + 3 * 6`은 `2 + (3 * 6)`의 연산 결과와 동일합니다.

이러한 연산을 수행할 때 주의해야 할 점은 곱셈 연산자보다 Number 구분자 `/`가 더 높은 우선순위를 가진다는 점입니다.
비빔에서 `2/3*3/7`라는 코드는 Number 구분자부터 연산되어 `2 / (3*3) / 7` -> `(2/9) / 7` -> `2/63`이 아닌 `(2/3) * (3/7)` -> `2/7`이 됩니다.
(Number 구분자 역시 왼쪽부터 평가됩니다.)

#### Null?
비빔에서 Number와 Bowl간의 덧셈, 뺄셈, 곱셈은 정의되지 않습니다. 이러한 연산을 수행하려 시도할 경우 특수한 값인 `Null`을 반환합니다. `Null`은 아무런 값도 의미하지 않으며, `Null`에 대해 어떠한 연산을 수행하더라도 그 결과는 언제나 `Null`이 됩니다.

### 비교 연산자
비빔에서는 총 세가지의 비교 연산자를 제공합니다.

`?=` 연산자는 두 Number가 같은지 평가합니다. 만약 두 Number의 값이 동일하다면 Number `1`을 반환합니다. 반대로 두 Number 값이 서로 다를 경우 Number `0`을 반환합니다.

예를 들어, `3 ?= 6` 은 `0`을 반환합니다. 또, `1/2 ?= 3/6`은 `1`을 반환합니다.

`>` 연산자는 두 Number 중 첫 번째 Number의 크기가 두 번째 Number의 크기보다 큰지 평가합니다. 만약 첫 번째 Number의 크기가 두 번째 Number의 크기보다 크다면 Number `1`을, 그렇지 않다면 Number `0`을 반환합니다.

예를 들어, `3 > 6` 은 `0`을 반환합니다. 또, `1 > 1`은 `0`을 반환합니다.

`<` 연산자는 두 Number 중 첫 번째 Number의 크기가 두 번째 Number의 크기보다 작은지 평가합니다. 만약 첫 번째 Number의 크기가 두 번째 Number의 크기보다 작다면 Number `1`을, 그렇지 않다면 Number `0`을 반환합니다.

예를 들어, `3 > 6` 은 `1`을 반환합니다. 또, `1 > 1`은 `0`을 반환합니다.

또한, 덧셈, 뺄셈이나 곱셈과 마찬가지로 비교 연산자는 Bowl에서 정의되지 않습니다. 이 경우 결과로 Number `0`을 반환하는 것이 아니라 `Null`을 반환하는 것에 유의하시기 바랍니다.

### 논리 연산자
비빔은 AND, OR과 NOT 연산자를 지원합니다. 이는 각각 `&`, `|`, `!` 문자를 사용하여 나타냅니다.

논리 연산을 평가할 때, 평가 결과가 Number `0`인 경우 거짓, 그 외의 Number인 경우 참으로 평가합니다.
또, 논리 연산의 결과는 참일 경우 Number `1`을. 거짓일 경우 Number `0`을 반환합니다.

예를 들어, `3 & 5`의 결과는 `1`, ` 7 | 0`의 결과는 `0`, `!9`는 `0`입니다.

주의해야 할 점은 `!` 연산자의 우선순위가 `&`와 `|`보다 높다는 점입니다. 따라서, `!1 & 0`의 평가 결과는 `0`입니다.

또, 평가하는 Number가 음수일 경우에도 `0`이 아니므로 참이라는 점, `&` 연산과 `|` 연산은 두 표현식을 반드시 모두 평가한다는 점 역시 유의해 주십시오.

만약 논리 연산자를 Bowl과 사용할 경우 언제나 `Null`을 반환합니다.

### 분모 연산자
비빔은 Number앞에 `^` 문자를 사용하여 Number의 분모를 가져올 수 있습니다.
따라서 `^1/3`은 `3`을 반환합니다.

(연산자 우선순위 관련 내용 추가. 곱셈이나 Bowl 참조 연산보다 높음, nubmer 구분자보다는 낮음)

역시 Bowl과 사용할 경우 `Null`을 반환합니다.

### Bowl 참조 연산
비빔은 `:` 연산자를 통해 Bowl이 담고 있는 Noodle의 Noodle expression을 참조할 수 있습니다. 이 때, `:` 연산자 앞의 표현식은 참조할 Bowl, 뒤의 표현식은 참조할 Noodle의 Noodle number입니다.

예를 들어 아래 코드를 평가한 결과는 `69`입니다.

    {
        [0; 72]
        [1; 69]
        [2; 76]
    }:1

만약 Bowl에 존재하지 않는 Noodle number를 참조하려고 시도한 경우 `Null`을 반환합니다.

(연산자 우선순위가 곱셈보다 높고 number 구분자보다 낮음)

`:` 연산자의 앞에 사용된 표현식이 Bowl이 아니거나, 뒤에 사용된 표현식이 Number가 아닐 경우 `Null`을 반환합니다.

### Bowl 대입 연산
비빔에서 `=` 연산자를 통해 Bowl에 Noodle을 추가하거나 수정할 수 있습니다.
표현식의 형태는 `<bowl>:<noodle number> = <noodle expression>`의 꼴입니다.

예를 들어 아래의 코드를 실행하면, 기존 Bowl에 담겨 있던 Noodle 중 Noodle number가 1인 Noodle의 Noodle expression이 72로 변경됩니다.

    {
        [0; 72]
        [1; 69]
        [2; 76]
    }:1 = 72

대입하는 noodle expression은 Number, Bowl 또는 Null일 수 있습니다.

만약 기존에 존재하지 않던 noodle number에 noodle expression을 대입한 경우 새로운 Noodle이 생성되어 해당 noodle number와 noodle expression을 갖습니다. 

사용시 주의해야 할 점은 `=` 연산자의 실행 결과는 항상 `Null`이라는 점입니다.

## 특수 Bowl `@`
비빔에서 `@` 문자는 사전에 정의된 특수한 Bowl을 나타냅니다. 이는 코드 어디에서나 접근할 수 있으며, 기존의 Bowl 자료형과 동일하게 사용할 수 있습니다.

그러나 noodle number `0`과 `1` 에 대해서 참조 연산과 대입 연산을 할 경우 약간 다른 결과를 보입니다.

### 현재 Noodle number `@:0`
비빔에서 `@:0`는 현재 *실행중인* Noodle number를 나타냅니다. 이는 이후 설명할 코드의 실행 절에서 더 상세히 설명합니다.

그 전에 알아두어야 할 것은 `@:0`에는 대입 연산을 수행할 수 없다는 점입니다. `@:0`에 값을 대입하려고 시도하더라도 실제로 `@:0`의 값이 변경되지 않습니다.

### IO Noodle number `@:1`
비빔에서 `@:1`는 입출력을 담당하는 특수 값입니다. 만약 `@:1`에 Bowl을 대입한 경우, 해당 Bowl을 문자열로 변환하여 표준 출력으로 출력합니다. 반대로 `@:1`의 값을 참조한 경우 표준 입력에서 문자열을 받아 Bowl로 변환한 결과를 반환합니다.

#### Bowl <-> String
비빔에는 문자열을 정의하는 특별한 자료형이 없습니다. 대신 Bowl을 문자열로 사용할 수 있습니다.

Bowl에 담겨 있는 각 Noodle의 noodle number가 0부터 시작하여 하나씩 증가하는 정수의 값을 가지고, noodle expression의 값이 모두 정수인 경우, noodle number 순서대로 noodle expression의 값을 utf-8로 인코딩된 unicode 값으로 사용하여 문자열을 나타냅니다.

예를 들어, 문자열 `HELLO WORLD`를 Bowl로 변환한 경우 아래와 같습니다.

    {
        [0; 72]
        [1; 69]
        [2; 76]
        [3; 76]
        [4; 79]
        [5; 32]
        [6; 87]
        [7; 79]
        [8; 82]
        [9; 76]
        [10; 68]
    }

만약 Bowl을 문자열로 변환하는 경우, 0보다 크거나 같은 정수 이외의 값을 noodle number로 가지는 Noodle을 무시합니다.


## 코딩과 실행
드디어 코딩입니다.
비빔으로 작성된 프로그램은 하나의 Bowl에 담깁니다.
이 Bowl에 담긴 Noodle들의 noodle number에 따라 noodle expression을 평가하면서 실행됩니다.

각 noodle의 평가되는 순서는 noodle number에 따라 결정됩니다.
프로그램이 처음 시작될 때는 0보다 크거나 같은 noodle number를 가지는 noodle중 가장 작은 noodle number를 가지는 noodle부터 평가하게 됩니다.

이후에는 마지막으로 실행한 noodle number보다 큰 noodle number를 가지는 noodle 중 가장 작은 noodle number를 가지는 noodle을 평가합니다.

만약 더 이상 마지막으로 실행한 noodle number보다 큰 noodle number를 가지는 noodle을 발견할 수 없을 경우 프로그램은 종료됩니다.


## 예제

### Hello world
    {
        [0; @:1 = {
            [0; 72]
            [1; 69]
            [2; 76]
            [3; 76]
            [4; 79]
            [5; 32]
            [6; 87]
            [7; 79]
            [8; 82]
            [9; 76]
            [10; 68]
            [11; 10]
        }]
    }

### echo
    {
        [0; @:1 = @:1]
    }
    

### fizzbuzz(주석)
    {
        [1/2; @:1/11 = {
            [0; 102]
            [1; 105]
            [2; 122]
            [3; 122]
        }]
        [2/3; @:2/11 = {
            [0; 98]
            [1; 117]
            [2; 122]
            [3; 122]
        }]
        [3/4; @:2 = 1]
        [4/5; @:3/11 = 1]
        [@:2 + 0; @:2/7 = @:3/11] ~# 함수 @:1/3을 호출하기 위해 출력할 정수 대입 #~
        [@:2 + 1; @:3/7 = 3] ~# 함수 @:1/3을 호출 후 이동할 위치 2 대입 #~
        [@:2 + 2; @:1/3 = @:0 + 1] ~# 함수 @:1/3을 호출 #~
        [@:3 + 0; @:1 = @:6/7] ~# 함수 @:1/3의 결과로 얻은 변환된 정수 문자열 출력 #~
        [@:3 + 1; @:1 = {
            [0; 58]
            [1; 32]
        }]
        [@:3 + 2; {
            [1; @:1 = @:1/11]
        }:(^((@:3/11)/3) ?= 1)]
        [@:3 + 4; {
            [1; @:1 = @:2/11]
        }:(^((@:3/11)/5) ?= 1)]
        [@:3 + 5; @:3/11 = @:3/11 + 1]
        [@:3 + 6; @:1 = {
            [0; 10]
        }]
        [@:3 + 7; {
            [1; @:2 = @:0 + 1]
        }:(@:3/11 < 101)]
    
        ~# 함수: @:1/2 = 정수의 길이를 반환 #~
        ~# 입력: @:2/5 = 확인할 정수, @:3/5 = 함수 종료 후 이동할 위치 #~
        ~# 출력: @:4/5 = 확인한 정수의 길이 #~
        [@:1/2; @:1/5 = @:0 + 3]
        [@:1/5 - 2; @:4/5 = 0] ~# 출력 결과에 0을 대입 #~
        [@:1/5 - 1; @:(0 - 1)/5 = @:2/5] ~# @:(0 - 1)/5 = 확인할 변수를 담은 임시 변수 #~
        [@:1/5 + 0; @:4/5 = @:4/5 + 1] ~# 출력 결과를 1 증가 #~
        [@:1/5 + 2; @:(0 - 1)/5 = (@:(0 - 1)/5) / 10] ~# @:(0 - 1)/5 를 10으로 나누어 다시 저장 #~
        [@:1/5 + 3; { ~# @:(0 - 1)/5 가 1보다 크거나 같으면 @:1/5로 되돌아감 #~
            [1; @:1/5 = @:0 + 1]
        }:!(@:(0 - 1)/5 < 1)]
        [@:1/5 + 4; @:(@:3/5) = @:0 + 1] ~# 함수 탈출 #~
    
        ~# 함수: @:1/3 = 정수를 자릿수별로 나눠서 ascii로 변환한 Pack으로 반환 #~
        ~# 입력: @:2/7 = 변환할 정수, @:3/7 = 함수 종료 후 이동할 위치 #~
        ~# 출력: @:6/7 = 변환된 Pack #~
        [@:1/3; @:1/7 = @:0 + 1]
        [@:1/7 + 0; @:6/7 = {}] ~# 변환 결과를 저장할 Pack 초기화 #~
        [@:1/7 + 1; @:(0 - 1)/7 = @:2/7] ~# 변환할 정수 임시 변수 @:(0 - 1)/7 에 복사 #~
        [@:1/7 + 2; @:2/5 = @:2/7] ~# 함수 @:1/2를 호출하기 위해 확인할 정수 대입 #~
        [@:1/7 + 3; @:3/5 = 1/13] ~# 함수 @:1/2를 호출 후 이동할 위치 1/13 지정 #~
        [@:1/7 + 4; @:1/2 = @:0 + 1] ~# 함수 @:1/2를 호출 #~
        [@:1/13 + 0; @:(0 - 2)/7 = @:4/5] ~# 함수 @:1/2 호출 결과(정수의 길이)를 임시 변수 @:(0 - 2)/7 에 저장 #~
        [@:1/13 + 1; @:(0 - 3)/7 = 0] ~# 자리수 확인용 변수 @:(0 - 3)/7 초기화 #~
        [@:1/13 + 2; { ~# 정수의 길이가 0이면 함수 종료 #~
            [0; @:1/17 = @:0 + 1] ~# 정수의 길이가 0이 아니므로 계속 실행 #~
            [1; @:(@:3/7) = @:0 + 1] ~# 정수의 길이가 0이므로 함수 종료 #~
        }:(@:(0 - 2)/7 ?= 0)]
        [@:1/17 + 0; @:(0 - 4)/7 = (@:(0 - 1)/7 - @:(0 - 3)/7)/10] ~# @:(0 - 4)/7 = (임시변수 1 - 임시변수 3) / 10 #~
        [@:1/17 + 1; { ~# @:(0 - 4)/7 의 분모가 1인 경우 @:(0 - 3)/7이 현재 마지막 자리의 자릿값임#~
            [0; @:1/19 = @:0 + 1] ~# @:(0 - 3)/7 를 1 증가시켜서 다시 확인하는 코드로 이동 #~
            [1; @:1/23 = @:0 + 1] ~# @:(0 - 3)/7 를 반환할 Pack에 추가하는 코드로 이동 #~
        }:(^(@:(0 - 4)/7) ?= 1)]
        [@:1/19 + 0; @:(0 - 3)/7 = @:(0 - 3)/7 + 1] ~# @:(0 - 3)/7 를 1 증가시킴 #~
        [@:1/19 + 1; @:1/13 = @:0 - 1] ~# @:1/13 + 2 로 이동 #~
        [@:1/23 + 0; @:(0 - 2)/7 = @:(0 - 2)/7 - 1] ~# @:(0 - 2)/7 (정수의 길이)를 1 감소시킴 #~
        [@:1/23 + 1; (@:6/7):(@:(0 - 2)/7) = @:(0 - 3)/7 + 48] ~# 반환할 pack의 (정수의 길이)번째에 현재 자리값을 대입 #~
        [@:1/23 + 2; @:(0 - 1)/7 = @:(0 - 4)/7] ~# @:(0 - 1)/7 의 마지막 자리수를 제거하여 대입 #~
        [@:1/23 + 3; @:1/13 = @:0 - 0] ~# @:1/13 + 1 로 이동 (자리값 초기화 수행하는 자리로) #~
    }
    
### fizzbuzz(AA)

    { [ 1 / 2 ; @ : 1 / 1 1 = { [ 0 ; 1 0 2 ] [ 1 ; 1 0 5 ] [ 2 ; 1 2 2 ]
     [ 3 ; 1 2 2 ] } ] [ 2 / 3 ; @ : 2 / 1 1 = { [ 0 ; 9 8 ] [ 1 ; 1 1 7 ]
    [ 2 ; 1 2 2 ] [ 3 ; 1 2 2 ] } ] [ 3 / 4 ; @ : 2 = 1 ] [ 4 / 5 ; @ : 3
     / 1 1 = 1 ] [ @ : 2 + 0 ; @ : 2 / 7 = @ : 3 / 1 1 ] [ @ : 2 + 1 ; @ :
    3 / 7 = 3 ] [ @ : 2 + 2 ; @ : 1 / 3 = @ : 0 + 1 ] [ @ : 3 + 0 ; @ : 1
     = @ : 6 / 7 ] [ @ : 3 + 1 ; @ : 1 = { [ 0 ; 5 8 ] [ 1 ; 3 2 ] } ] [ @
    : 3 + 2 ; { [ 1 ; @ : 1 = @ : 1 / 1 1 ] } : ( ^ ( ( @ : 3 / 1 1 ) / 3
     ) ? = 1 ) ] [ @ : 3 + 4 ; { [ 1 ; @ : 1 = @ : 2 / 1 1 ] } : ( ^ ( ( @
    : 3 / 1 1 ) / 5 ) ? = 1 ) ] [ @ : 3 + 5 ; @ : 3 / 1 1 = @ : 3 / 1 1 +
     1 ] [ @ : 3 + 6 ; @ : 1 = { [ 0 ; 1 0 ] } ] [ @ : 3 + 7 ; { [ 1 ; @ :
    2 = @ : 0 + 1 ] } : ( @ : 3 / 1 1 < 1 0 1 ) ] [ @ : 1 / 2 ; @ : 1 / 5
     = @ : 0 + 3 ] [ @ : 1 / 5 - 2 ; @ : 4 / 5 = 0 ] [ @ : 1 / 5 - 1 ; @ :
    ( 0 - 1 ) / 5 = @ : 2 / 5 ] [ @ : 1 / 5 + 0 ; @ : 4 / 5 = @ : 4 / 5 +
     1 ] [ @ : 1 / 5 + 2 ; @ : ( 0 - 1 ) / 5 = ( @ : ( 0 - 1 ) / 5 ) / 1 0
    ] [ @ : 1 / 5 + 3 ; { [ 1 ; @ : 1 / 5 = @ : 0 + 1 ] } : ! ( @ : ( 0 -
     1 ) / 5 < 1 ) ] [ @ : 1 / 5 + 4 ; @ : ( @ : 3 / 5 ) = @ : 0 + 1 ] [ @
    : 1 / 3 ; @ : 1 / 7 = @ : 0 + 1 ] [ @ : 1 / 7 + 0 ; @ : 6 / 7 = { } ]
     [ @ : 1 / 7 + 1 ; @ : ( 0 - 1 ) / 7 = @ : 2 / 7 ] [ @ : 1 / 7 + 2 ; @
    : 2 / 5 = @ : 2 / 7 ] [ @ : 1 / 7 + 3 ; @ : 3 / 5 = 1 / 1 3 ] [ @ : 1
     / 7 + 4 ; @ : 1 / 2 = @ : 0 + 1 ] [ @ : 1 / 1 3 + 0 ; @ : ( 0 - 2 ) /
    7 = @ : 4 / 5 ] [ @ : 1 / 1 3 + 1 ; @ : ( 0 - 3 ) / 7 = 0 ] [ @ : 1 /
     1 3 + 2 ; { [ 0 ; @ : 1 / 1 7 = @ : 0 + 1 ] [ 1 ; @ : ( @ : 3 / 7 ) =
    @ : 0 + 1 ] } : ( @ : ( 0 - 2 ) / 7 ? = 0 ) ] [ @ : 1 / 1 7 + 0 ; @ :
     ( 0 - 4 ) / 7 = ( @ : ( 0 - 1 ) / 7 - @ : ( 0 - 3 ) / 7 ) / 1 0 ] [ @
    : 1 / 1 7 + 1 ; { [ 0 ; @ : 1 / 1 9 = @ : 0 + 1 ] [ 1 ; @ : 1 / 2 3 =
     @ : 0 + 1 ] } : ( ^ ( @ : ( 0 - 4 ) / 7 ) ? = 1 ) ] [ @ : 1 / 1 9 + 0
    ; @ : ( 0 - 3 ) / 7 = @ : ( 0 - 3 ) / 7 + 1 ] [ @ : 1 / 1 9 + 1 ; @ :
     1 / 1 3 = @ : 0 - 1 ] [ @ : 1 / 2 3 + 0 ; @ : ( 0 - 2 ) / 7 = @ : ( 0
    - 2 ) / 7 - 1 ] [ @ : 1 / 2 3 + 1 ; ( @ : 6 / 7 ) : ( @ : ( 0 - 2 ) /
     7 ) = @ : ( 0 - 3 ) / 7 + 4 8 ] [ @ : 1 / 2 3 + 2 ; @ : ( 0 - 1 ) / 7
    = @ : ( 0 - 4 ) / 7 ] [ @ : 1 / 2 3 + 3 ; @ : 1 / 1 3 = @ : 0 - 0 ] }

#TODO
TODO: 주석 얘기

TODO: 공백 무시

TODO: @:0 얘기 추가

TODO: 주석 정리

TODO: 깔끔하게 다시쓰기

# Bibim(비빔)
비빔은 당신의 두뇌를 즐겁게 만들어 줄 새로운 프로그래밍 언어입니다.

여기서는 비빔의 문법에 대해서 설명합니다.

## 공백 문자
비빔 문법에 대해 설명하기 전에, 비빔에서는 모든 공백 문자를 무시한다는 점을 먼저 말씀드립니다.
비빔에서는 그 어떠한 상황에서도 공백 문자는 의미를 갖지 않습니다.

따라서 단 하나의 띄어쓰기 없이 한 줄에 비빔 코드를 작성한다 하더라도 문제없이 동작하며, 심지어는 비빔 코드의 모든 문자 사이에 공백 문자를 삽입하여 코드의 길이를 두배로 늘려도 아주 잘 실행됩니다.

## 인코딩
비빔으로 작성된 모든 코드는 UTF-8로 인코딩되어야만 합니다. 이는 비빔이 지원하는 입출력 방식이 유니코드로 이루어지기 때문입니다. 이는 이후 입출력에 대해 설명하면서 다시 언급할 것입니다.

## 주석
가장 먼저 알아볼 비빔 문법은 주석입니다. 비빔에서 주석은 `~# 내용 #~`과 같은 꼴로 사용됩니다.
최근에 사용되는 많은 프로그래밍 언어들과는 다르게 비빔에서는 주석의 시작과 끝을 반드시 지정해주어야 합니다.

당연하게도 `~# 주석의 끝은 #~ 입니다. #~`와 같은 주석을 작성하면 중간의 `#~` 이후의 내용은 주석으로서 평가되지 않기 때문에 오류가 발생합니다.

## 자료형
비빔의 자료형은 크게 Number와 Bowl, 두 가지로 구성됩니다.

### Number
Number는 비빔에서 '수'를 나타내는 자료형입니다.
비빔에서 '수'란 유리수를 의미합니다. 이러한 수는 부동소수점으로 표기되지 않고, 분수꼴로 표현됩니다. 따라서 비빔에서는 유리수 연산에서 부동소수점 오차가 발생하지 않습니다.

비빔에서 Number를 표현하기 위해서는 Number 구분자 `/`를 사용합니다. `/` 문자 앞에 사용된 Number를 분자로, `/` 문자 뒤에 사용된 Number를 분모로 사용하여 새로운 Number 값을 만듭니다.

예를 들어, 비빔에서 `3/5`는 유리수 3/5와 동일합니다. 또, `1/3`은 유리수 1/3과 동일합니다.

또, 정수 값들은 분모가 1인 Number입니다. 이 경우 `/` 문자를 생략하고 정수만을 표기하여 사용할 수 있습니다. (위의 예제에서도 분자와 분모로 사용된 숫자 1, 3, 5는 각각 분모가 생략된 Number입니다.)

새로운 Number를 정의할 때, 비빔은 내부적으로 Number를 분모와 분자 모두 정수로 이루어진 기약분수 형태로 변환합니다.

### Noodle
Bowl에 대해 설명하기 앞서, Noodle에 대해 먼저 설명합니다.

Noodle은 비빔에서 어떠한 표현식(Expression)에 Noodle number를 부여하는 특수한 구문(자료형이 아닙니다)입니다. 
Noodle은 `[` 문자로 시작하여 `]` 문자로 끝나며, 중간에 구분자 `;`를 가집니다. 구분자 `;`를 기준으로 앞의 표현식을 Noodle number, 뒤의 표현식을 Noodle exprsssion이라고 부릅니다.

예를 들면, `[3/4; 2/3]`와 같은 구문은 Noodle을 나타내며, Noodle number는 `3/4`, Noodle expression은 `2/3`입니다.

Noodle을 정의할 때, 구분자 `;`는 반드시 포함해야 하며, Noodle number와 Noodle expression 역시 반드시 포함해야 합니다.

### Bowl
Bowl은 Noodle의 뭉치로 표현되는 비빔에서 사용되는 특수한 자료형입니다.
이는 `{` 문자로 시작하여 `}` 문자로 끝나며, Noodle을 특별한 구분자 없이 담아 정의합니다.

예를 들면, 아래의 코드는 총 12개의 Noodle을 담고 있는 Bowl입니다.

    {
        [0; 72]
        [1; 69]
        [2; 76]
        [3; 76]
        [4; 79]
        [5; 32]
        [6; 87]
        [7; 79]
        [8; 82]
        [9; 76]
        [10; 68]
        [11; 10]
    }

또한 어떠한 Noodle도 담고 있지 않는 Bowl 역시 정의할 수 있는데, 이 경우는 간단히 `{}`와 같이 표현합니다.

## 연산자
이제 비빔에서 사용할 수 있는 연산자에 대해 알아봅시다.

### 소괄호
소괄호 문자 `(`, `)`를 사용하여 표현식의 연산 우선순위를 지정할 수 있습니다.
비빔은 소괄호 안의 표현식을 우선적으로 평가합니다.

### 덧셈, 뺄셈, 곱셈
비빔에서는 각각 `+`, `-`, `*` 연산자를 이용하여 두 Number간의 덧셈, 뺄셈과 곱셈 연산을 수행할 수 있습니다.
예를 들어 `1/4 + 1/2`의 연산 결과는 `3/4`가 됩니다.

곱셈은 덧셈과 뺄셈보다 높은 우선순위로 평가되며, 덧셈과 뺄셈은 동일한 우선순위를 같습니다.
동일한 우선순위를 가지는 덧셈, 뺄셈, 곱셈 연산자는 왼쪽부터 평가됩니다.

예를 들어, `2 + 3 * 6`은 `2 + (3 * 6)`의 연산 결과와 동일합니다.

이러한 연산을 수행할 때 주의해야 할 점은 곱셈 연산자보다 Number 구분자 `/`가 더 높은 우선순위를 가진다는 점입니다.
비빔에서 `2/3*3/7`라는 코드는 Number 구분자부터 연산되어 `((2 / 3) * 3) / 7` -> `2 / 7` 이 아닌 `(2 / 3) * (3 / 7)` -> `2 / 7` 과 같은 순서로 평가됩니다.
(Number 구분자 역시 왼쪽부터 평가됩니다.)

#### Null?
비빔에서 Number와 Bowl간의 덧셈, 뺄셈, 곱셈은 정의되지 않습니다. 이러한 연산을 수행하려 시도할 경우 특수한 값인 `Null`을 반환합니다. `Null`은 아무런 값도 의미하지 않으며, `Null`에 대해 어떠한 연산을 수행하더라도 그 결과는 언제나 `Null`이 됩니다.

### 비교 연산자
비빔에서는 총 세가지의 비교 연산자를 제공합니다.

`?=` 연산자는 두 Number가 같은지 평가합니다. 만약 두 Number의 값이 동일하다면 Number `1`을 반환합니다. 반대로 두 Number 값이 서로 다를 경우 Number `0`을 반환합니다.

예를 들어, `3 ?= 6` 은 `0`을 반환합니다. 또, `1/2 ?= 3/6`은 `1`을 반환합니다.

`>` 연산자는 두 Number 중 첫 번째 Number의 크기가 두 번째 Number의 크기보다 큰지 평가합니다. 만약 첫 번째 Number의 크기가 두 번째 Number의 크기보다 크다면 Number `1`을, 그렇지 않다면 Number `0`을 반환합니다.

예를 들어, `3 > 6` 은 `0`을 반환합니다. 또, `1 > 1`은 `0`을 반환합니다.

`<` 연산자는 두 Number 중 첫 번째 Number의 크기가 두 번째 Number의 크기보다 작은지 평가합니다. 만약 첫 번째 Number의 크기가 두 번째 Number의 크기보다 작다면 Number `1`을, 그렇지 않다면 Number `0`을 반환합니다.

예를 들어, `3 > 6` 은 `1`을 반환합니다. 또, `1 > 1`은 `0`을 반환합니다.

또한, 덧셈, 뺄셈이나 곱셈과 마찬가지로 비교 연산자는 Bowl에서 정의되지 않습니다. 이 경우 결과로 Number `0`을 반환하는 것이 아니라 `Null`을 반환하는 것에 유의하시기 바랍니다.

### 논리 연산자
비빔은 AND, OR과 NOT 연산자를 지원합니다. 이는 각각 `&`, `|`, `!` 문자를 사용하여 나타냅니다.

논리 연산을 평가할 때, 평가 결과가 Number `0`인 경우 거짓, 그 외의 Number인 경우 참으로 평가합니다.
또, 논리 연산의 결과는 참일 경우 Number `1`을. 거짓일 경우 Number `0`을 반환합니다.

예를 들어, `3 & 5`의 결과는 `1`, ` 7 | 0`의 결과는 `0`, `!9`는 `0`입니다.

주의해야 할 점은 `!` 연산자의 우선순위가 `&`와 `|`보다 높다는 점입니다.

또, 평가하는 Number가 음수일 경우에도 `0`이 아니므로 참이라는 점, `&` 연산과 `|` 연산은 앞뒤 두 표현식을 반드시 모두 평가한다는 점 역시 유의해 주십시오.

만약 논리 연산자를 Bowl과 사용할 경우 언제나 `Null`을 반환합니다.

### 분모 연산자
비빔은 Number앞에 `^` 문자를 사용하여 Number의 분모를 가져올 수 있습니다.
따라서 `^1/3`은 `3`을 반환합니다.

`^` 문자는 곱셈보다는 먼저, Number 구분자보다는 나중에 평가됩니다.
따라서, `^1/3 * 1/7`은  `(^(1/3)) * (1/7)`와 동일한 순서로 평가됩니다.

역시 Bowl과 사용할 경우 `Null`을 반환합니다.

### Bowl 참조 연산
비빔은 `:` 연산자를 통해 Bowl이 담고 있는 Noodle의 Noodle expression을 참조할 수 있습니다. 이 때, `:` 연산자 앞의 표현식은 참조할 Bowl, 뒤의 표현식은 참조할 Noodle의 Noodle number입니다.

예를 들어 아래 코드를 평가한 결과는 `69`입니다.

    {
        [0; 72]
        [1; 69]
        [2; 76]
    }:1

만약 Bowl에 존재하지 않는 Noodle number를 참조하려고 시도한 경우 `Null`을 반환합니다.

Bowl 참조 연산은 분모 연산자보다는 높은 우선순위로 평가되지만 Number 구분자보다는 나중에 평가됩니다.

`:` 연산자의 앞에 사용된 표현식이 Bowl이 아니거나, 뒤에 사용된 표현식이 Number가 아닐 경우 `Null`을 반환합니다.

### Bowl 대입 연산
비빔에서 `=` 연산자를 통해 Bowl에 Noodle을 추가하거나 수정할 수 있습니다.
표현식의 형태는 `<bowl>:<noodle number> = <noodle expression>`의 꼴입니다.

예를 들어 아래의 코드를 실행하면, 기존 Bowl에 담겨 있던 Noodle 중 Noodle number가 1인 Noodle의 Noodle expression이 72로 변경됩니다.

    {
        [0; 72]
        [1; 69]
        [2; 76]
    }:1 = 72

대입하는 noodle expression은 Number, Bowl 또는 Null일 수 있습니다.

만약 기존에 존재하지 않던 noodle number에 noodle expression을 대입한 경우 새로운 Noodle이 생성되어 해당 noodle number와 noodle expression을 갖습니다. 

사용시 주의해야 할 점은 `=` 연산자의 실행 결과는 항상 `Null`이라는 점입니다.

## 특수 Bowl `@`
비빔에서 `@` 문자는 사전에 정의된 특수한 Bowl을 나타냅니다. 이는 코드 어디에서나 접근할 수 있으며, 기존의 Bowl 자료형과 동일하게 사용할 수 있습니다.

그러나 noodle number `0`과 `1` 에 대해서 참조 연산과 대입 연산을 할 경우 약간 다른 결과를 보입니다.

### 현재 Noodle number `@:0`
비빔에서 `@:0`는 현재 *실행중인* Noodle number를 나타냅니다. 이는 이후 설명할 코드의 실행 절에서 더 상세히 설명합니다.

그 전에 알아두어야 할 것은 `@:0`에는 대입 연산을 수행할 수 없다는 점입니다. `@:0`에 값을 대입하려고 시도하더라도 실제로 `@:0`의 값이 변경되지 않습니다.

### IO Noodle number `@:1`
비빔에서 `@:1`는 입출력을 담당하는 특수 값입니다. 만약 `@:1`에 Bowl을 대입한 경우, 해당 Bowl을 문자열로 변환하여 표준 출력으로 출력합니다. 반대로 `@:1`의 값을 참조한 경우 표준 입력에서 문자열을 받아 Bowl로 변환한 결과를 반환합니다.

#### Bowl <-> String
비빔에는 문자열을 정의하는 특별한 자료형이 없습니다. 대신 Bowl을 문자열로 사용할 수 있습니다.

Bowl에 담겨 있는 각 Noodle의 noodle number가 0부터 시작하여 하나씩 증가하는 정수의 값을 가지고, noodle expression의 값이 모두 정수인 경우, noodle number 순서대로 noodle expression의 값을 utf-8로 인코딩된 unicode 값으로 사용하여 문자열을 나타냅니다.

예를 들어, 문자열 `HELLO WORLD`를 Bowl로 변환한 경우 아래와 같습니다.

    {
        [0; 72]
        [1; 69]
        [2; 76]
        [3; 76]
        [4; 79]
        [5; 32]
        [6; 87]
        [7; 79]
        [8; 82]
        [9; 76]
        [10; 68]
    }

만약 Bowl을 문자열로 변환하는 경우, 0보다 크거나 같은 정수 이외의 값을 noodle number로 가지는 Noodle을 무시합니다.


## 코딩과 실행
드디어 코딩입니다.
비빔으로 작성된 프로그램은 하나의 Bowl에 담깁니다.
이 Bowl에 담긴 Noodle들의 noodle number에 따라 noodle expression을 평가하면서 실행됩니다.

각 noodle의 평가되는 순서는 noodle number에 따라 결정됩니다.
프로그램이 처음 시작될 때는 0보다 크거나 같은 noodle number를 가지는 noodle중 가장 작은 noodle number를 가지는 noodle부터 평가하게 됩니다.

이후에는 마지막으로 실행한 noodle number보다 큰 noodle number를 가지는 noodle 중 가장 작은 noodle number를 가지는 noodle을 평가합니다.

만약 더 이상 마지막으로 실행한 noodle number보다 큰 noodle number를 가지는 noodle을 발견할 수 없을 경우 프로그램은 종료됩니다.

이 때, 마지막으로 실행한 Noodle number는 특수 Bowl `@`의 Noodle중 Noodle number가 `0`인 Noodle의 Noodle expression과 동일합니다.
따라서 비빔 코드에서 `@:0`과 같이 Bowl 참조 연산을 통해 현재 실행하고 있는 Noodle number의 값을 알아낼 수 있습니다.
여기서 `@:0`의 결과가 *현재* 실행하고 있는 Noodle number임에 유의하세요. 비빔에서는 새로운 Noodle expression을 평가하기 전에 해당 Noodle number의 값을 `@:0`에 지정합니다.

또, `@:0`에 지정되는 Noodle number는 실행중인 비빔 코드의 최외부 Bowl에 담겨있는 Noodle에 한합니다.


## 예제

### Hello world
    {
        [0; @:1 = {
            [0; 72]
            [1; 69]
            [2; 76]
            [3; 76]
            [4; 79]
            [5; 32]
            [6; 87]
            [7; 79]
            [8; 82]
            [9; 76]
            [10; 68]
            [11; 10]
        }]
    }

### echo
    {
        [0; @:1 = @:1]
    }
    

### fizzbuzz(주석)
    {
        [1/2; @:1/11 = {
            [0; 102]
            [1; 105]
            [2; 122]
            [3; 122]
        }]
        [2/3; @:2/11 = {
            [0; 98]
            [1; 117]
            [2; 122]
            [3; 122]
        }]
        [3/4; @:2 = 1]
        [4/5; @:3/11 = 1]
        [@:2 + 0; @:2/7 = @:3/11] ~# 함수 @:1/3을 호출하기 위해 출력할 정수 대입 #~
        [@:2 + 1; @:3/7 = 3] ~# 함수 @:1/3을 호출 후 이동할 위치 2 대입 #~
        [@:2 + 2; @:1/3 = @:0 + 1] ~# 함수 @:1/3을 호출 #~
        [@:3 + 0; @:1 = @:6/7] ~# 함수 @:1/3의 결과로 얻은 변환된 정수 문자열 출력 #~
        [@:3 + 1; @:1 = {
            [0; 58]
            [1; 32]
        }]
        [@:3 + 2; {
            [1; @:1 = @:1/11]
        }:(^((@:3/11)/3) ?= 1)]
        [@:3 + 4; {
            [1; @:1 = @:2/11]
        }:(^((@:3/11)/5) ?= 1)]
        [@:3 + 5; @:3/11 = @:3/11 + 1]
        [@:3 + 6; @:1 = {
            [0; 10]
        }]
        [@:3 + 7; {
            [1; @:2 = @:0 + 1]
        }:(@:3/11 < 101)]
    
        ~# 함수: @:1/2 = 정수의 길이를 반환 #~
        ~# 입력: @:2/5 = 확인할 정수, @:3/5 = 함수 종료 후 이동할 위치 #~
        ~# 출력: @:4/5 = 확인한 정수의 길이 #~
        [@:1/2; @:1/5 = @:0 + 3]
        [@:1/5 - 2; @:4/5 = 0] ~# 출력 결과에 0을 대입 #~
        [@:1/5 - 1; @:(0 - 1)/5 = @:2/5] ~# @:(0 - 1)/5 = 확인할 변수를 담은 임시 변수 #~
        [@:1/5 + 0; @:4/5 = @:4/5 + 1] ~# 출력 결과를 1 증가 #~
        [@:1/5 + 2; @:(0 - 1)/5 = (@:(0 - 1)/5) / 10] ~# @:(0 - 1)/5 를 10으로 나누어 다시 저장 #~
        [@:1/5 + 3; { ~# @:(0 - 1)/5 가 1보다 크거나 같으면 @:1/5로 되돌아감 #~
            [1; @:1/5 = @:0 + 1]
        }:!(@:(0 - 1)/5 < 1)]
        [@:1/5 + 4; @:(@:3/5) = @:0 + 1] ~# 함수 탈출 #~
    
        ~# 함수: @:1/3 = 정수를 자릿수별로 나눠서 ascii로 변환한 Bowl으로 반환 #~
        ~# 입력: @:2/7 = 변환할 정수, @:3/7 = 함수 종료 후 이동할 위치 #~
        ~# 출력: @:6/7 = 변환된 Bowl #~
        [@:1/3; @:1/7 = @:0 + 1]
        [@:1/7 + 0; @:6/7 = {}] ~# 변환 결과를 저장할 Bowl 초기화 #~
        [@:1/7 + 1; @:(0 - 1)/7 = @:2/7] ~# 변환할 정수 임시 변수 @:(0 - 1)/7 에 복사 #~
        [@:1/7 + 2; @:2/5 = @:2/7] ~# 함수 @:1/2를 호출하기 위해 확인할 정수 대입 #~
        [@:1/7 + 3; @:3/5 = 1/13] ~# 함수 @:1/2를 호출 후 이동할 위치 1/13 지정 #~
        [@:1/7 + 4; @:1/2 = @:0 + 1] ~# 함수 @:1/2를 호출 #~
        [@:1/13 + 0; @:(0 - 2)/7 = @:4/5] ~# 함수 @:1/2 호출 결과(정수의 길이)를 임시 변수 @:(0 - 2)/7 에 저장 #~
        [@:1/13 + 1; @:(0 - 3)/7 = 0] ~# 자리수 확인용 변수 @:(0 - 3)/7 초기화 #~
        [@:1/13 + 2; { ~# 정수의 길이가 0이면 함수 종료 #~
            [0; @:1/17 = @:0 + 1] ~# 정수의 길이가 0이 아니므로 계속 실행 #~
            [1; @:(@:3/7) = @:0 + 1] ~# 정수의 길이가 0이므로 함수 종료 #~
        }:(@:(0 - 2)/7 ?= 0)]
        [@:1/17 + 0; @:(0 - 4)/7 = (@:(0 - 1)/7 - @:(0 - 3)/7)/10] ~# @:(0 - 4)/7 = (임시변수 1 - 임시변수 3) / 10 #~
        [@:1/17 + 1; { ~# @:(0 - 4)/7 의 분모가 1인 경우 @:(0 - 3)/7이 현재 마지막 자리의 자릿값임#~
            [0; @:1/19 = @:0 + 1] ~# @:(0 - 3)/7 를 1 증가시켜서 다시 확인하는 코드로 이동 #~
            [1; @:1/23 = @:0 + 1] ~# @:(0 - 3)/7 를 반환할 Bowl에 추가하는 코드로 이동 #~
        }:(^(@:(0 - 4)/7) ?= 1)]
        [@:1/19 + 0; @:(0 - 3)/7 = @:(0 - 3)/7 + 1] ~# @:(0 - 3)/7 를 1 증가시킴 #~
        [@:1/19 + 1; @:1/13 = @:0 - 1] ~# @:1/13 + 2 로 이동 #~
        [@:1/23 + 0; @:(0 - 2)/7 = @:(0 - 2)/7 - 1] ~# @:(0 - 2)/7 (정수의 길이)를 1 감소시킴 #~
        [@:1/23 + 1; (@:6/7):(@:(0 - 2)/7) = @:(0 - 3)/7 + 48] ~# 반환할 Bowl의 (정수의 길이)번째에 현재 자리값을 대입 #~
        [@:1/23 + 2; @:(0 - 1)/7 = @:(0 - 4)/7] ~# @:(0 - 1)/7 의 마지막 자리수를 제거하여 대입 #~
        [@:1/23 + 3; @:1/13 = @:0 - 0] ~# @:1/13 + 1 로 이동 (자리값 초기화 수행하는 자리로) #~
    }
    
### fizzbuzz(AA)

    { [ 1 / 2 ; @ : 1 / 1 1 = { [ 0 ; 1 0 2 ] [ 1 ; 1 0 5 ] [ 2 ; 1 2 2 ]
     [ 3 ; 1 2 2 ] } ] [ 2 / 3 ; @ : 2 / 1 1 = { [ 0 ; 9 8 ] [ 1 ; 1 1 7 ]
    [ 2 ; 1 2 2 ] [ 3 ; 1 2 2 ] } ] [ 3 / 4 ; @ : 2 = 1 ] [ 4 / 5 ; @ : 3
     / 1 1 = 1 ] [ @ : 2 + 0 ; @ : 2 / 7 = @ : 3 / 1 1 ] [ @ : 2 + 1 ; @ :
    3 / 7 = 3 ] [ @ : 2 + 2 ; @ : 1 / 3 = @ : 0 + 1 ] [ @ : 3 + 0 ; @ : 1
     = @ : 6 / 7 ] [ @ : 3 + 1 ; @ : 1 = { [ 0 ; 5 8 ] [ 1 ; 3 2 ] } ] [ @
    : 3 + 2 ; { [ 1 ; @ : 1 = @ : 1 / 1 1 ] } : ( ^ ( ( @ : 3 / 1 1 ) / 3
     ) ? = 1 ) ] [ @ : 3 + 4 ; { [ 1 ; @ : 1 = @ : 2 / 1 1 ] } : ( ^ ( ( @
    : 3 / 1 1 ) / 5 ) ? = 1 ) ] [ @ : 3 + 5 ; @ : 3 / 1 1 = @ : 3 / 1 1 +
     1 ] [ @ : 3 + 6 ; @ : 1 = { [ 0 ; 1 0 ] } ] [ @ : 3 + 7 ; { [ 1 ; @ :
    2 = @ : 0 + 1 ] } : ( @ : 3 / 1 1 < 1 0 1 ) ] [ @ : 1 / 2 ; @ : 1 / 5
     = @ : 0 + 3 ] [ @ : 1 / 5 - 2 ; @ : 4 / 5 = 0 ] [ @ : 1 / 5 - 1 ; @ :
    ( 0 - 1 ) / 5 = @ : 2 / 5 ] [ @ : 1 / 5 + 0 ; @ : 4 / 5 = @ : 4 / 5 +
     1 ] [ @ : 1 / 5 + 2 ; @ : ( 0 - 1 ) / 5 = ( @ : ( 0 - 1 ) / 5 ) / 1 0
    ] [ @ : 1 / 5 + 3 ; { [ 1 ; @ : 1 / 5 = @ : 0 + 1 ] } : ! ( @ : ( 0 -
     1 ) / 5 < 1 ) ] [ @ : 1 / 5 + 4 ; @ : ( @ : 3 / 5 ) = @ : 0 + 1 ] [ @
    : 1 / 3 ; @ : 1 / 7 = @ : 0 + 1 ] [ @ : 1 / 7 + 0 ; @ : 6 / 7 = { } ]
     [ @ : 1 / 7 + 1 ; @ : ( 0 - 1 ) / 7 = @ : 2 / 7 ] [ @ : 1 / 7 + 2 ; @
    : 2 / 5 = @ : 2 / 7 ] [ @ : 1 / 7 + 3 ; @ : 3 / 5 = 1 / 1 3 ] [ @ : 1
     / 7 + 4 ; @ : 1 / 2 = @ : 0 + 1 ] [ @ : 1 / 1 3 + 0 ; @ : ( 0 - 2 ) /
    7 = @ : 4 / 5 ] [ @ : 1 / 1 3 + 1 ; @ : ( 0 - 3 ) / 7 = 0 ] [ @ : 1 /
     1 3 + 2 ; { [ 0 ; @ : 1 / 1 7 = @ : 0 + 1 ] [ 1 ; @ : ( @ : 3 / 7 ) =
    @ : 0 + 1 ] } : ( @ : ( 0 - 2 ) / 7 ? = 0 ) ] [ @ : 1 / 1 7 + 0 ; @ :
     ( 0 - 4 ) / 7 = ( @ : ( 0 - 1 ) / 7 - @ : ( 0 - 3 ) / 7 ) / 1 0 ] [ @
    : 1 / 1 7 + 1 ; { [ 0 ; @ : 1 / 1 9 = @ : 0 + 1 ] [ 1 ; @ : 1 / 2 3 =
     @ : 0 + 1 ] } : ( ^ ( @ : ( 0 - 4 ) / 7 ) ? = 1 ) ] [ @ : 1 / 1 9 + 0
    ; @ : ( 0 - 3 ) / 7 = @ : ( 0 - 3 ) / 7 + 1 ] [ @ : 1 / 1 9 + 1 ; @ :
     1 / 1 3 = @ : 0 - 1 ] [ @ : 1 / 2 3 + 0 ; @ : ( 0 - 2 ) / 7 = @ : ( 0
    - 2 ) / 7 - 1 ] [ @ : 1 / 2 3 + 1 ; ( @ : 6 / 7 ) : ( @ : ( 0 - 2 ) /
     7 ) = @ : ( 0 - 3 ) / 7 + 4 8 ] [ @ : 1 / 2 3 + 2 ; @ : ( 0 - 1 ) / 7
    = @ : ( 0 - 4 ) / 7 ] [ @ : 1 / 2 3 + 3 ; @ : 1 / 1 3 = @ : 0 - 0 ] }

TODO: 깔끔하게 다시쓰기
